/**
 * CVE Verifier â€” validates CVE IDs against GitHub Advisory Database
 * No external dependencies; uses Node.js built-in https module.
 */

const https = require('https');

class CVEVerifier {
  /**
   * @param {object} [opts]
   * @param {string} [opts.githubToken] - Optional GitHub PAT for higher rate limits
   */
  constructor(opts = {}) {
    this.githubToken = opts.githubToken || process.env.GITHUB_TOKEN || null;
  }

  /**
   * Validate CVE ID format
   * @param {string} cveId
   * @returns {boolean}
   */
  static isValidCVEFormat(cveId) {
    return /^CVE-\d{4}-\d{4,}$/.test(cveId);
  }

  /**
   * Fetch advisory data from GitHub Advisory Database API
   * @param {string} cveId  e.g. "CVE-2026-26960"
   * @returns {Promise<object>} { valid, severity, summary, publishedAt, references, affectedPackages, raw }
   */
  async lookup(cveId) {
    if (!CVEVerifier.isValidCVEFormat(cveId)) {
      return { valid: false, error: `Invalid CVE format: ${cveId}` };
    }

    const url = `https://api.github.com/advisories?cve_id=${encodeURIComponent(cveId)}`;
    let data;
    try {
      data = await this._fetch(url);
    } catch (err) {
      return { valid: false, error: `API request failed: ${err.message}` };
    }

    if (!Array.isArray(data) || data.length === 0) {
      return { valid: false, cveId, severity: null, summary: null, publishedAt: null, references: [], affectedPackages: [] };
    }

    const advisory = data[0];
    return {
      valid: true,
      cveId,
      severity: advisory.severity || null,
      summary: advisory.summary || null,
      publishedAt: advisory.published_at || null,
      references: (advisory.references || []).map(r => (typeof r === 'string' ? r : r.url)).filter(Boolean),
      affectedPackages: (advisory.vulnerabilities || []).map(v => ({
        ecosystem: v.package?.ecosystem || null,
        name: v.package?.name || null,
        vulnerableRange: v.vulnerable_version_range || null,
      })),
      ghsaId: advisory.ghsa_id || null,
      htmlUrl: advisory.html_url || null,
      raw: advisory,
    };
  }

  /**
   * Check whether a URL is a legitimate GitHub advisory link
   * @param {string} url
   * @returns {{ legitimate: boolean, reason: string }}
   */
  static checkAdvisoryUrl(url) {
    try {
      const parsed = new URL(url);
      const isGitHub = parsed.hostname === 'github.com' && parsed.pathname.startsWith('/advisories/');
      if (isGitHub) {
        return { legitimate: true, reason: 'URL points to official GitHub Advisory Database' };
      }
      return { legitimate: false, reason: `Domain "${parsed.hostname}" is not github.com/advisories` };
    } catch {
      return { legitimate: false, reason: 'Invalid URL' };
    }
  }

  /**
   * Verify a CVE + optional suspicious URL together
   * @param {string} cveId
   * @param {string} [suspiciousUrl]
   * @returns {Promise<object>}
   */
  async verify(cveId, suspiciousUrl) {
    const result = await this.lookup(cveId);
    if (suspiciousUrl) {
      result.urlCheck = CVEVerifier.checkAdvisoryUrl(suspiciousUrl);
    }
    return result;
  }

  /** @private */
  _fetch(url) {
    return new Promise((resolve, reject) => {
      const headers = {
        'User-Agent': 'ClawMoat-CVE-Verifier',
        'Accept': 'application/vnd.github+json',
      };
      if (this.githubToken) {
        headers['Authorization'] = `Bearer ${this.githubToken}`;
      }

      https.get(url, { headers }, (res) => {
        let body = '';
        res.on('data', chunk => body += chunk);
        res.on('end', () => {
          if (res.statusCode !== 200) {
            return reject(new Error(`HTTP ${res.statusCode}: ${body.slice(0, 200)}`));
          }
          try {
            resolve(JSON.parse(body));
          } catch (e) {
            reject(new Error(`JSON parse error: ${e.message}`));
          }
        });
        res.on('error', reject);
      }).on('error', reject);
    });
  }
}

module.exports = { CVEVerifier };
