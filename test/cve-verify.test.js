const { describe, it, beforeEach, mock } = require('node:test');
const assert = require('node:assert');
const { CVEVerifier } = require('../src/guardian/cve-verify');

describe('CVEVerifier', () => {
  describe('isValidCVEFormat', () => {
    it('accepts valid CVE IDs', () => {
      assert.strictEqual(CVEVerifier.isValidCVEFormat('CVE-2024-1234'), true);
      assert.strictEqual(CVEVerifier.isValidCVEFormat('CVE-2026-26960'), true);
      assert.strictEqual(CVEVerifier.isValidCVEFormat('CVE-2023-99999'), true);
    });

    it('rejects invalid formats', () => {
      assert.strictEqual(CVEVerifier.isValidCVEFormat('CVE-123-1234'), false);
      assert.strictEqual(CVEVerifier.isValidCVEFormat('CVE-2024-12'), false);
      assert.strictEqual(CVEVerifier.isValidCVEFormat('cve-2024-1234'), false);
      assert.strictEqual(CVEVerifier.isValidCVEFormat('not-a-cve'), false);
      assert.strictEqual(CVEVerifier.isValidCVEFormat(''), false);
      assert.strictEqual(CVEVerifier.isValidCVEFormat('CVE-abcd-efgh'), false);
    });
  });

  describe('checkAdvisoryUrl', () => {
    it('accepts legitimate GitHub advisory URLs', () => {
      const r = CVEVerifier.checkAdvisoryUrl('https://github.com/advisories/GHSA-1234-5678-9abc');
      assert.strictEqual(r.legitimate, true);
    });

    it('rejects non-GitHub domains', () => {
      const r = CVEVerifier.checkAdvisoryUrl('https://github-security.com/advisories/fake');
      assert.strictEqual(r.legitimate, false);
    });

    it('rejects GitHub URLs not in /advisories/', () => {
      const r = CVEVerifier.checkAdvisoryUrl('https://github.com/darfaz/clawmoat');
      assert.strictEqual(r.legitimate, false);
    });

    it('rejects invalid URLs', () => {
      const r = CVEVerifier.checkAdvisoryUrl('not a url');
      assert.strictEqual(r.legitimate, false);
    });
  });

  describe('lookup', () => {
    it('rejects invalid CVE format without making API call', async () => {
      const v = new CVEVerifier();
      const result = await v.lookup('bad-format');
      assert.strictEqual(result.valid, false);
      assert.ok(result.error);
    });

    it('returns structured result for valid lookup (mocked)', async () => {
      const v = new CVEVerifier();
      // Mock the internal _fetch method
      v._fetch = async () => [{
        ghsa_id: 'GHSA-test-1234',
        severity: 'high',
        summary: 'Test vulnerability',
        published_at: '2024-01-15T00:00:00Z',
        html_url: 'https://github.com/advisories/GHSA-test-1234',
        references: ['https://example.com/ref1'],
        vulnerabilities: [{
          package: { ecosystem: 'npm', name: 'test-pkg' },
          vulnerable_version_range: '< 2.0.0',
        }],
      }];

      const result = await v.lookup('CVE-2024-12345');
      assert.strictEqual(result.valid, true);
      assert.strictEqual(result.severity, 'high');
      assert.strictEqual(result.summary, 'Test vulnerability');
      assert.strictEqual(result.ghsaId, 'GHSA-test-1234');
      assert.strictEqual(result.affectedPackages.length, 1);
      assert.strictEqual(result.affectedPackages[0].name, 'test-pkg');
      assert.strictEqual(result.references.length, 1);
    });

    it('returns valid=false when API returns empty array (mocked)', async () => {
      const v = new CVEVerifier();
      v._fetch = async () => [];
      const result = await v.lookup('CVE-2024-99999');
      assert.strictEqual(result.valid, false);
      assert.strictEqual(result.cveId, 'CVE-2024-99999');
    });

    it('handles API errors gracefully (mocked)', async () => {
      const v = new CVEVerifier();
      v._fetch = async () => { throw new Error('Network error'); };
      const result = await v.lookup('CVE-2024-12345');
      assert.strictEqual(result.valid, false);
      assert.ok(result.error.includes('Network error'));
    });
  });

  describe('verify', () => {
    it('includes URL check when suspiciousUrl provided', async () => {
      const v = new CVEVerifier();
      v._fetch = async () => [{ severity: 'medium', summary: 'Test', published_at: '2024-01-01', references: [], vulnerabilities: [] }];
      const result = await v.verify('CVE-2024-12345', 'https://evil.com/fake-advisory');
      assert.strictEqual(result.valid, true);
      assert.ok(result.urlCheck);
      assert.strictEqual(result.urlCheck.legitimate, false);
    });

    it('marks legitimate GitHub advisory URLs', async () => {
      const v = new CVEVerifier();
      v._fetch = async () => [{ severity: 'high', summary: 'Real', published_at: '2024-01-01', references: [], vulnerabilities: [] }];
      const result = await v.verify('CVE-2024-12345', 'https://github.com/advisories/GHSA-xxxx');
      assert.strictEqual(result.urlCheck.legitimate, true);
    });
  });

  describe('constructor options', () => {
    it('accepts githubToken option', () => {
      const v = new CVEVerifier({ githubToken: 'test-token' });
      assert.strictEqual(v.githubToken, 'test-token');
    });

    it('defaults to no token', () => {
      const saved = process.env.GITHUB_TOKEN;
      delete process.env.GITHUB_TOKEN;
      const v = new CVEVerifier();
      assert.strictEqual(v.githubToken, null);
      if (saved) process.env.GITHUB_TOKEN = saved;
    });
  });
});
